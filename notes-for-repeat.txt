//trying not to be stuck in a tutoriall hell I am trying to revise 
// const http =require(http)
// const server = http.createServer((req,res)=>{

// })
// server.listen(5000)
//  req (request) and res (response) is key to working with servers in Node.js. Here's a breakdown of what each one is and how they work:
// The req object represents the incoming request from the client (usually a browser, app, or API client like Postman).

// It contains details about what the client is asking for.
// the res object is what you send back to the client. You use it to build the response.
// server.listen(5000);This tells the server to start listening for incoming requests on port 5000.
// A method is a function inside an object:
// In res.write .write is a method 
res	The response you (the server) send to the client
res.writeHead()	Set status code & headers
res.end(data)	Send back the body and close the connection
packages, modules and dependencies are used interchangebly 
üõ£Ô∏è The npx route: No global mess.
Instead of cluttering your system with global installs, you can just run:

bash
Copy
Edit
npx nodemon index.js
This does one of two things:

If nodemon is installed locally in your project, it uses that.

If not, it downloads it temporarily, runs it, then throws it away after.
package-lock.json: sometimes dependencies with version number also have dependencies of their own with their own version number and therefore we need to ensure that these version numbers dont change overtime so that the functionality remains the same
JavaScript can‚Äôt do two things at once (it's single-threaded), so the event loop helps it fake multitasking by:

üß† Running all your code synchronously line-by-line

üì§ Sending async tasks (like timers, network requests) to the Web APIs (browser-side) or libuv (Node.js-side)

üì• Putting the finished async callbacks in a queue (aka the callback/message/microtask queue)

üåÄ The event loop checks if the call stack is empty ‚Üí if yes, it pushes the queued tasks back onto the stack


üß± What is a "sandboxed environment"?
In programming, a sandbox is a safe, limited space where code can run without being able to mess with the system it's running on.

Web APIs (in the browser context) are features provided by the browser, not by JavaScript itself. They handle tasks that JavaScript can't do alone because JS runs in a secure sandboxed environment.

Behind the scenes:
When you call resolve(), it marks the Promise as fulfilled and stores the value you passed in.

When you call reject(), it marks the Promise as rejected and stores the error you passed in.

Then:

.then() runs with the resolve value

.catch() runs with the reject error
still dk
Arrow functions DON‚ÄôT have their own this.

So if you're inside a class or object and using this, arrow functions act differently.

Example:

js
Copy
Edit
const obj = {
  name: "Ananya",
  regularFunc: function () {
    console.log("regular:", this.name); // ‚úÖ "Ananya"
  },
  arrowFunc: () => {
    console.log("arrow:", this.name); // ‚ùå undefined
  }
}

obj.regularFunc();
obj.arrowFunc();